#stl学习笔记
参照《Primer C++》系统的学习一遍stl, 把重要的知识点记录下来

## 顺序容器
标准库定义了三种顺序容器：vector、list、deque(双端队列), 他们的差别在于访问元素的方式以及添加或删除元素的相关操作的代价;还提供了三种容器适配器: stack、queue、priority_queue.

### 容器的构造函数
* `C<T> c;` 创建一个空容器, 适用所有容器
* `C<T> c(c2);` 创建容器c2的副本, 适用所有容器
* `C<T> c(b,e);` 创建c, 其元素是迭代器b和e标示范围内元素的副本, 适用所有容器
* `C<T> c(n,t);` 用n个值为t的元素创建容器, 其中t必须是容器C的元素类型的值或者可转换为该类型, 仅适用顺序容器
* `C<T> c(n);` 创建有n个值初始化元素的容器c, 仅适用顺序容器

注意：  
1. 将一个容器复制给另一个容器时, 类型必须匹配：容器类型和元素类型都必须相同  
2. 使用迭代器时, 不要求容器类型相同, 元素类型相互兼容即可实现复制. 迭代器需要标记出要复制的第一个元素和最后一个元素  
3. 由于指针就是迭代器, 因此允许指针实现容器初始化. 第二个指向的是停止复制的条件, 其所指向位置的元素未被复制
4. 只提供元素个数时, 元素必须为内置或复合类型, 或者提供了默认构造函数的类型
```cpp
char *words[] = {'111','222','333'};
list<string> words2(words, words+3)
```
### 容器内元素的类型约束
* 元素类型必须支持赋值运算
* 元素类型对象必须可以复制
* 因为容易受容器元素类型的约束, 因此可以定义元素是容器类型的容器. 注意中间需加空格

### 迭代器
**常用运算：**  
* `*iter` 返回迭代器指向元素的引用
* `iter->mem` 对iter解引用, 获得指定元素的mem成员.  等效于`(*iter).mem`
* `++iter iter++` 使iter指向下一个元素
* `--iter iter--` 使iter指向前一个元素
* `iter1==iter2 iter1!=iter2` 比较两个迭代器是否相等. 当指向同一个容器同一个元素或者同一个容器超出末端的下一个元素时相等

**vector和deque迭代器额外运算：**  
* `iter+n iter-n` 在迭代器上加(减)整数值n, 产生指向容器中前面(后面)第n个元素的迭代器. 新计算出来的迭代器必须指向容器中的元素或超出容器末尾的下一个位置
* `iter1 - iter2` 计算结果为加上右边的迭代器等于左边的迭代器
* `> >= < <=` 返回迭代器相对位置  
这是由于只有vector和deque容器为其元素提供了快速、随机的访问, 确保可根据元素位置直接有效地访问指定的容器元素, 使得他们的迭代器可以有效的实现算术和关系运算

**使迭代器失效的容器操作：**  
一些容器操作修改容器内在状态或移动容器内的元素, 会导致指向被移动的元素的迭代器失效, 也可能同时使其他迭代器失效. 使用无效的迭代器可能导致与使用空指针相同的问题  

### 顺序容器的类型定义与操作
**类型别名:** 
* size_type 无符号整型, 足以存储此容器类型最大可能容器长度
* iterator 此容器类型的迭代器类型
* const_iterator 元素的只读迭代器类型
* reverse_iterator 按逆序寻址元素的迭代器
* const_reverse_iterator 元素的只读逆序迭代器
* difference_type 足够存储两个迭代器差值的有符号整型
* value_tpye 元素类型
* reference 元素的左值类型, 是`value_type&`的同义词
* const_reference 元素的常量左值类型, 等效于`const value_type&`  

**begin和end成员：**  
begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器
* c.begin() 返回一个迭代器, 指向c的第一个元素
* c.end() 返回一个迭代器, 指向c的最后一个元素的下一个位置
* c.rbegin() 返回一个逆序迭代器, 指向容易c的最后一个元素
* c.rend() 返回一个逆序迭代器, 指向容器c的第一个元素前面的位置  
每个操作均有两个版本, 如果容器是const, 则其返回类型要加上`const_`前缀

**添加元素的操作：**
容器元素都是副本, 系统是将元素值复制到容器中. 被复制的原始值与新容器中的元素各不相关  
* `c.push_back(t)` 在容器c的尾部添加值为t的元素, 返回void
* `c.push_front(t)` 在容器c的前端添加值为t的元素, 只适用于list和deque容器类型, 返回void
* `c.insert(p,t)` 在迭代器p所指向的元素前面插入值为t的新元素, 返回*指向新添加元素的迭代器*
* `c.insert(p,n,t)` 在迭代器p所指向的元素前面插入n个值为t的新元素, 返回void
* `c.insert(p,b,e)` 在迭代器p所指向的元素前面插入由迭代器b和e标识范围内的元素, 返回void  

1. 任何insert或push操作都可能导致迭代器失效, 当编写循环将元素插入到vector或deque容器中时, 程序必须确保迭代器在每次循环后都得到更新  
2. 避免存储end操作返回的迭代器, 添加或删除deque或vector容器内的元素都会导致存储的迭代器失效. 可以在每次完成插入运算后重新计算end迭代器  

**顺序容器的大小操作：**
* `c.size()` 返回容器c中的元素个数. 返回类型为c::size_type
* `c.max_size()` 返回容器c可容纳的的最多元素个数. 返回类型为c::size_type
* `c.empty()` 返回容器大小是否为0
* `c.resize(n)` 调整容器c的长度大小, 使其能容纳n个元素. 如果`n<c.size()`, 删除多余的元素; 否则添加初始化的新元素
* `c.resize(n,t)` 调整容器c的长度大小, 使其能容纳n个元素. 所有新增加的元素值都为t  
1. resize操作会是vector和deque的所有迭代器失效
2. 对于所有的容器类型, 如果resize操作压缩了容器, 则指向已删除的元素迭代器失效

**访问元素：**  
* `c.back()` 返回容器c的最后一个元素的引用, 为空则此操作未定义
* `c.front()` 返回容器c的第一个元素的引用, 为空则此操作未定义
* `c[n]` 返回下标为n的元素的引用, 只适合vector和deque, 下标越界则未定义
* `c.at(n)` 类似`c[n]`, 但n越界会跑出out_of_range异常

```cpp
if(!ilist.empty()){
    list<int>::reference val = *ilist.begin();
    list<int>::reference val2 = ilist.front();
    
    list<int>::reference last = *--ilist.end();
    list<int>::reference last2 = ilist.back();
}
```

**删除元素：**
* `c.erase(p)` 删除迭代器p指向的元素, 返回一个迭代器指向被删除元素后面的元素. 如果p指向最后一个元素, 则返回超出容器末端的下一个位置
* `c.erase(b,e)` 删除迭代器b和e所标记的范围内所有的元素, 返回一个迭代器指向被删除元素后面的元素
* `c.clear()` 删除容器c内的所有元素, 返回void
* `c.pop_back()` 删除容器c的最后一个元素, 返回void
* `c.pop_front` 删除容器c的第一个元素, 返回void. 只适用于list或deque容器

1. pop_front和pop_back返回的不是删除元素的值, 而是void








 

