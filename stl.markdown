#stl学习笔记
参照《Primer C++》系统的学习一遍stl, 把重要的知识点记录下来

## 顺序容器
标准库定义了三种顺序容器：vector、list、deque(双端队列), 他们的差别在于访问元素的方式以及添加或删除元素的相关操作的代价;还提供了三种容器适配器: stack、queue、priority_queue.

### 容器的构造函数
* `C<T> c;` 创建一个空容器, 适用所有容器
* `C<T> c(c2);` 创建容器c2的副本, 适用所有容器
* `C<T> c(b,e);` 创建c, 其元素是迭代器b和e标示范围内元素的副本, 适用所有容器
* `C<T> c(n,t);` 用n个值为t的元素创建容器, 其中t必须是容器C的元素类型的值或者可转换为该类型, 仅适用顺序容器
* `C<T> c(n);` 创建有n个值初始化元素的容器c, 仅适用顺序容器

注意：  
1. 将一个容器复制给另一个容器时, 类型必须匹配：容器类型和元素类型都必须相同  
2. 使用迭代器时, 不要求容器类型相同, 元素类型相互兼容即可实现复制. 迭代器需要标记出要复制的第一个元素和最后一个元素  
3. 由于指针就是迭代器, 因此允许指针实现容器初始化. 第二个指向的是停止复制的条件, 其所指向位置的元素未被复制
4. 只提供元素个数时, 元素必须为内置或复合类型, 或者提供了默认构造函数的类型
```cpp
char *words[] = {'111','222','333'};
list<string> words2(words, words+3);
```
### 容器内元素的类型约束
* 元素类型必须支持赋值运算
* 元素类型对象必须可以复制
* 因为容易受容器元素类型的约束, 因此可以定义元素是容器类型的容器. 注意中间需加空格

### 迭代器
**常用运算：**  
* `*iter` 返回迭代器指向元素的引用
* `iter->mem` 对iter解引用, 获得指定元素的mem成员.  等效于`(*iter).mem`
* `++iter iter++` 使iter指向下一个元素
* `--iter iter--` 使iter指向前一个元素
* `iter1==iter2 iter1!=iter2` 比较两个迭代器是否相等. 当指向同一个容器同一个元素或者同一个容器超出末端的下一个元素时相等

**vector和deque迭代器额外运算：**  
* `iter+n iter-n` 在迭代器上加(减)整数值n, 产生指向容器中前面(后面)第n个元素的迭代器. 新计算出来的迭代器必须指向容器中的元素或超出容器末尾的下一个位置
* `iter1 - iter2` 计算结果为加上右边的迭代器等于左边的迭代器
* `> >= < <=` 返回迭代器相对位置  
这是由于只有vector和deque容器为其元素提供了快速、随机的访问, 确保可根据元素位置直接有效地访问指定的容器元素, 使得他们的迭代器可以有效的实现算术和关系运算

**使迭代器失效的容器操作：**  
一些容器操作修改容器内在状态或移动容器内的元素, 会导致指向被移动的元素的迭代器失效, 也可能同时使其他迭代器失效. 使用无效的迭代器可能导致与使用空指针相同的问题  

### 顺序容器的类型定义与操作
**类型别名:** 
* size_type 无符号整型, 足以存储此容器类型最大可能容器长度
* iterator 此容器类型的迭代器类型
* const_iterator 元素的只读迭代器类型
* reverse_iterator 按逆序寻址元素的迭代器
* const_reverse_iterator 元素的只读逆序迭代器
* difference_type 足够存储两个迭代器差值的有符号整型
* value_tpye 元素类型
* reference 元素的左值类型, 是`value_type&`的同义词
* const_reference 元素的常量左值类型, 等效于`const value_type&`  

**begin和end成员：**  
begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器
* `c.begin()` 返回一个迭代器, 指向c的第一个元素
* `c.end()` 返回一个迭代器, 指向c的最后一个元素的下一个位置
* `c.rbegin()` 返回一个逆序迭代器, 指向容易c的最后一个元素
* `c.rend()` 返回一个逆序迭代器, 指向容器c的第一个元素前面的位置  
每个操作均有两个版本, 如果容器是const, 则其返回类型要加上`const_`前缀

**添加元素的操作：**  
容器元素都是副本, 系统是将元素值复制到容器中. 被复制的原始值与新容器中的元素各不相关  
* `c.push_back(t)` 在容器c的尾部添加值为t的元素, 返回void
* `c.push_front(t)` 在容器c的前端添加值为t的元素, 只适用于list和deque容器类型, 返回void
* `c.insert(p,t)` 在迭代器p所指向的元素前面插入值为t的新元素, 返回*指向新添加元素的迭代器*
* `c.insert(p,n,t)` 在迭代器p所指向的元素前面插入n个值为t的新元素, 返回void
* `c.insert(p,b,e)` 在迭代器p所指向的元素前面插入由迭代器b和e标识范围内的元素, 返回void  

1. 任何insert或push操作都可能导致迭代器失效, 当编写循环将元素插入到vector或deque容器中时, 程序必须确保迭代器在每次循环后都得到更新  
2. 避免存储end操作返回的迭代器, 添加或删除deque或vector容器内的元素都会导致存储的迭代器失效. 可以在每次完成插入运算后重新计算end迭代器  

**顺序容器的大小操作：**  
* `c.size()` 返回容器c中的元素个数. 返回类型为c::size_type
* `c.max_size()` 返回容器c可容纳的的最多元素个数. 返回类型为c::size_type
* `c.empty()` 返回容器大小是否为0
* `c.resize(n)` 调整容器c的长度大小, 使其能容纳n个元素. 如果`n<c.size()`, 删除多余的元素; 否则添加初始化的新元素
* `c.resize(n,t)` 调整容器c的长度大小, 使其能容纳n个元素. 所有新增加的元素值都为t  
1. resize操作会是vector和deque的所有迭代器失效
2. 对于所有的容器类型, 如果resize操作压缩了容器, 则指向已删除的元素迭代器失效

**访问元素：**  
* `c.back()` 返回容器c的最后一个元素的引用, 为空则此操作未定义
* `c.front()` 返回容器c的第一个元素的引用, 为空则此操作未定义
* `c[n]` 返回下标为n的元素的引用, 只适合vector和deque, 下标越界则未定义
* `c.at(n)` 类似`c[n]`, 但n越界会跑出out_of_range异常

```cpp
if(!ilist.empty()){
    list<int>::reference val = *ilist.begin();
    list<int>::reference val2 = ilist.front();
    
    list<int>::reference last = *--ilist.end();
    list<int>::reference last2 = ilist.back();
}
```

**删除元素：**
* `c.erase(p)` 删除迭代器p指向的元素, 返回一个迭代器指向被删除元素后面的元素. 如果p指向最后一个元素, 则返回超出容器末端的下一个位置
* `c.erase(b,e)` 删除迭代器b和e所标记的范围内所有的元素, 返回一个迭代器指向被删除元素后面的元素
* `c.clear()` 删除容器c内的所有元素, 返回void
* `c.pop_back()` 删除容器c的最后一个元素, 返回void
* `c.pop_front()` 删除容器c的第一个元素, 返回void. 只适用于list或deque容器

1. pop_front和pop_back返回的不是删除元素的值, 而是void
2. erase, pop_front, pop_back函数会使指向被删除元素的所有迭代器失效. vector容器会使其后的元素迭代器失效, deque如果删除不包含第一个或最后一个元素则所有迭代器都会失效  

```cpp
string searchValue("abc")
list<string>::iterator iter = find(slist.begin(), slist.end(), searchValue);
if(iter != slist.end())
    slist.erase(iter);
```

**赋值与swap：**
* `c1 = c2` 删除容器c1的所有元素, 然后将c2的元素复制给c1. c1和c2的类型(容器和元素类型)必须相同
* `c1.swap(c2)` c1与c2交换内容
* `c.assign(b,e)` 重新设置c的元素, 将迭代器b,e标识范围内的元素复制到c中
* `c.assign(n,t)` 将容器c重新存储为n个值为t的元素

1. 与赋值相关的操作符作用于整个容器, 除了swap操作外其他操作都可以用erase和insert操作实现
2. 赋值要求容器和元素类型必须一致, 但assign可以对不同容器、不同但相互兼容的元素类型操作
3. swap要交换的容器类型和元素类型必须一致. 由于swap操作不会删除或插入任何元素, 容器内没有移动任何元素, 因此迭代器不会失效. 如果一个迭代器iter指向svec1[3], swap运算后该迭代器指向svec2[3]

```cpp
slist1 = slist2;
slist1.assign(slist2.begin(), slist2.end());
slist1.assign(10, "abc!");
```

**capacity和reserve：**
* `capacity()`操作获取在容器需要分配更多存储空间之前能够存储的元素总数
* `reserve()`操作告诉vector容器应该预留多少个元素的存储空间
* `size()`操作指容器当前拥有的元素个数

### 容器选用
* 如果程序要求随机访问元素, 则应使用vector或deque容器
* 如果程序必须在容器的中间位置插入或删除元素, 则应采用list容器
* 如果程序不是在中间位置而是容器首部或尾部插入或删除元素, 则采用deque容器
* 如果读取输入时在容器中间位置插入元素, 然后需要随机访问. 可以先读入到list容器, 在复制到vector容器中

### string类型
pass  

### 容器适配器  
除了顺序容器, 标准库还提供了三种顺序容器适配器: queue, priority_queue, stack  
**适配器**包含容器适配器、迭代器适配器和函数适配器. 本质上, 适配器是使一事物的行为类似于另一事物的行为的一种机制. 容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现. 例如stack适配器可使任何一种顺序容器以栈的方式工作  
 
**通用的操作和类型**  
* size_type 一种类型, 足以存储此适配器类型最大对象的长度
* value_tpye 元素类型
* container_type 基础容器的类型, 适配器在此容器类型上实现
* `A a` 创建一个新空适配器
* `A a(c)` 创建一个新适配器, 初始化为容器c的副本
* 关系操作符 适配器都支持`== != < <= > >=` 

**覆盖基础容器类型**  
1. 默认的stack和queue都是基于deque容器实现的, 而priority_queue则是在vector容器上实现的  
2. 在创建适配器时, 通过将一个顺序容器指定为适配器的第二个类型实参, 可覆盖其关联的基础容器类型  
3. 对于给定适配器, 其关联容器必须满足一定的约束条件. *stack*关联的基础容器可以是任意一种顺序容器类型, 因此可以建立在vector, list或deque上; *queue*要求基础容器必须提供push_front运算, 因此不能建立在vector上; *priority_queue*要求提供随机访问能力, 因此可以建立在vector和deque上, 不能建立在list上  

```cpp
stack<string, vector<string> > str_stk;
stack<string, vector<string> > str_stk(svec);
```

**栈适配器**  
* `s.empty()` 如果栈为空, 返回true否则false
* `s.size()` 返回栈中元素的个数
* `s.push(item)` 在栈顶压入新元素
* `s.pop()` 删除栈顶元素的值, 但不返回其值
* `s.top()` 返回栈顶元素的值, 但不删除该元素


**队列和优先级队列**  
必须包含"queue"头文件. queue为先入先出队列, priority_queue允许用户为队列中存储的元素设置优先级, 将元素放在比他优先级低的元素前面  
* `q.empty()` 如果队列为空, 返回true否则false  
* `q.size()` 返回队列中元素的个数
* `q.push(item)` 对于queue在队尾压入一个新元素, 在优先级队列基于优先级的适当位置插入新元素
* `q.pop()` 删除首元素, 但不返回值
* `q.front()` 返回队首元素的值, 但不删除. 只适用于队列
* `q.back()` 返回队尾元素的值, 但不删除. 只适用于队列
* `q.top()` 返回具有最高优先级的元素, 但不删除. 只适用于优先级队列  







 

